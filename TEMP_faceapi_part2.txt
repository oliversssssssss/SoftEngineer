    """
    å°†å¤šå¼ åŒä¸€äººçš„å›¾ç‰‡å†™å…¥æ•°æ®åº“ï¼š
      - å¯¹æ¯å¼ å›¾å–è¯„åˆ†æœ€é«˜çš„äººè„¸ -> å¯¹é½ -> embedding
      - æ±‚å‡å€¼å‘é‡å¹¶ L2 å½’ä¸€åŒ?
      - è¿½åŠ å…¥åº“å¹¶ä¿å­?outputs/embeddings.npy & labels.json
    """
    global DB_EMB, DB_LABELS

    try:
        if not body.name:
            raise ValueError("name ä¸èƒ½ä¸ºç©º")
        if not body.images_base64:
            raise ValueError("images_base64 ä¸èƒ½ä¸ºç©º")

        vecs = []
        for b64 in body.images_base64:
            img_bgr = _decode_base64_to_bgr(b64)
            img_rgb = bgr2rgb(img_bgr)
            faces = DETECTOR.detect_faces(img_rgb)
            if not faces:
                continue
            f = max(faces, key=lambda x: x["score"])
            aligned = align_face(img_rgb, f["keypoints"], size=IMAGE_SIZE)
            vec = EMB_MODEL.get_embedding(aligned)
            vecs.append(vec)

        if not vecs:
            raise ValueError("æ‰€æœ‰å›¾ç‰‡éƒ½æœªæ£€æµ‹åˆ°å¯ç”¨äººè„¸")

        mean_vec = np.mean(np.stack(vecs, axis=0), axis=0)
        mean_vec = mean_vec / (np.linalg.norm(mean_vec) + 1e-12)

        with DB_LOCK:
            if DB_EMB is None or DB_LABELS is None or len(DB_LABELS) == 0:
                DB_EMB = np.expand_dims(mean_vec, axis=0)  # (1, 512)
                DB_LABELS = [body.name]
            else:
                DB_EMB = np.concatenate([DB_EMB, np.expand_dims(mean_vec, axis=0)], axis=0)
                DB_LABELS.append(body.name)

            save_db(DB_EMB, DB_LABELS, out_emb=str(EMB_PATH), out_labels=str(LBL_PATH))

        return {"ok": True, "name": body.name, "images_used": len(vecs), "db_size": len(DB_LABELS)}

    except Exception as e:
        raise HTTPException(status_code=400, detail=str(e))
